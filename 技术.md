# 智能农业监控系统技术原理文档

## 目录

1. [硬件架构](#硬件架构)
2. [传感器模块工作原理](#传感器模块工作原理)
   - [DHT11温湿度传感器](#dht11温湿度传感器)
   - [光敏电阻传感器](#光敏电阻传感器)
   - [MQ2气体传感器](#mq2气体传感器)
   - [MPU6050姿态传感器](#mpu6050姿态传感器)
3. [输出模块工作原理](#输出模块工作原理)
   - [LED指示系统](#led指示系统)
   - [蓝牙通信模块](#蓝牙通信模块)
   - [蜂鸣器报警模块](#蜂鸣器报警模块)
4. [LCD显示系统](#lcd显示系统)
   - [多页面UI设计](#多页面ui设计)
   - [按键切换机制](#按键切换机制)
5. [软件架构设计](#软件架构设计)
   - [主循环机制](#主循环机制)
   - [数据采集策略](#数据采集策略)
   - [阈值判断与报警](#阈值判断与报警)
6. [蓝牙命令解析](#蓝牙命令解析)

## 硬件架构

本系统基于STM32F407VGT6微控制器，这是一款基于ARM Cortex-M4内核的高性能32位MCU，主频168MHz，具有1MB Flash和192KB RAM。整体硬件架构采用"星形"拓扑结构，以STM32F407为中心连接多个功能模块，包括传感器、通信接口和人机交互设备。

系统电气连接图：

```
                        ┌────────────┐
                        │   电源管理  │
                        └─────┬──────┘
                              │
┌───────────────┐      ┌──────┴───────┐     ┌───────────────┐
│  DHT11温湿度   ├──────┤              │     │     按键模块   │
└───────────────┘      │              ├─────┤ (KEY0~KEY3)   │
                       │              │     └───────────────┘
┌───────────────┐      │   STM32F407  │     ┌───────────────┐
│ 光敏电阻(ADC3) ├──────┤   主控制器   ├─────┤    LCD显示    │
└───────────────┘      │              │     └───────────────┘
                       │              │
┌───────────────┐      │              │     ┌───────────────┐
│   MQ2气体传感器├──────┤              ├─────┤  蓝牙HC-05    │
└───────────────┘      └──────┬───────┘     └───────────────┘
                              │
┌───────────────┐      ┌──────┴───────┐     ┌───────────────┐
│  MPU6050姿态  ├──────┤  LED/蜂鸣器  │     │  扩展接口      │
└───────────────┘      └──────────────┘     └───────────────┘
```

## 传感器模块工作原理

### DHT11温湿度传感器

**工作原理**：
DHT11是一款数字温湿度复合传感器，内部集成了高精度的温度测量元件和电容式湿度测量元件，以及一个8位单片机。采用单总线协议，只需一根数据线即可完成通信。

**通信过程**：
1. 主机发送起始信号（拉低数据线至少18ms）
2. 主机释放总线，等待DHT11响应
3. DHT11拉低总线80μs，然后拉高80μs作为响应
4. DHT11连续发送40位数据（8位湿度整数+8位湿度小数+8位温度整数+8位温度小数+8位校验和）
5. 传输完成后DHT11自动进入低功耗模式

**数据获取方式**：
```c
uint8_t dht11_read_dat(uint8_t *temperature, uint8_t *humidity)
```
函数通过位定时采样读取DHT11输出的40位数据，提取其中的温湿度值，并通过校验和验证数据有效性。返回0表示读取成功，非0表示失败。

**数值含义**：
- 温度范围：0~50℃，精度±2℃，分辨率0.1℃（实际有效精度通常为整数）
- 湿度范围：20~90%RH，精度±5%RH，分辨率0.1%RH（实际有效精度通常为整数）

### 光敏电阻传感器

**工作原理**：
光敏电阻是一种随入射光强度变化而改变电阻值的器件，基于半导体光电效应。光照强度越大，电阻值越小；光照强度越小，电阻值越大。通过电阻分压电路将电阻值变化转换为电压变化，再通过ADC转换为数字信号。

**数据获取方式**：
```c
uint16_t Light_GetRawValue(void)
```
该函数调用`Get_Adc3(5)`读取ADC3通道5的数值。ADC配置为12位分辨率，参考电压为3.3V，因此ADC转换结果范围为0~4095。

**数值处理与转换**：
```c
sensor_data.light_raw_value = Light_GetRawValue();
sensor_data.light_percent = 100 - (sensor_data.light_raw_value * 100 / 4095);
```
原始ADC值与光照强度成反比，需要进行反向转换：
- ADC值为0：表示光照最强，转换为100%光照强度
- ADC值为4095：表示光照最弱，转换为0%光照强度

**ADC原理**：
ADC3使用STM32F407内置的12位SAR型ADC，采样时间设置为480个周期，以确保转换精度。为提高采样稳定性，采用软件触发单次转换模式，每次读取时等待EOC（转换结束）标志。

```c
ADC_RegularChannelConfig(ADC3, ADC_Channel_5, 1, ADC_SampleTime_480Cycles);
ADC_SoftwareStartConv(ADC3);
while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC));
return ADC_GetConversionValue(ADC3);
```

### MQ2气体传感器

**工作原理**：
MQ2气体传感器基于SnO2材料对可燃性气体的敏感特性，当周围存在可燃性气体时，传感器的电导率会增加。传感器包含加热电路和信号处理电路，输出模拟电压信号。该传感器对甲烷、丁烷、LPG、氢气、烟雾等气体敏感。

**数据获取方式**：
MQ2传感器通过专用接口进行通信，包括以下步骤：
```c
MQ2_ClearFlag();           // 清除数据标志
MQ2_SendCommand();         // 发送读取命令
// 等待数据就绪
while(!MQ2_IsDataReady() && (system_tick - wait_start) < 200);
// 获取数据
sensor_data.smoke_ppm_value = MQ2_GetValue();
```

**数值含义**：
- 原始输出为ppm值（每百万体积单位中的气体分子数）
- 典型检测范围：300~10000ppm
- 在本项目中，将ppm值除以10转换为百分比，用于报警判断：
  ```c
  sensor_data.smoke_percent = (float)sensor_data.smoke_ppm_value / 10.0f;
  ```

**预热特性**：
MQ2传感器需要较长的预热时间（1~2分钟）才能稳定工作，因此系统初始化时需要给予足够的预热时间。预热过程中，传感器的数值可能不准确。

### MPU6050姿态传感器

**工作原理**：
MPU6050是一款集成了三轴加速度计和三轴陀螺仪的6轴运动处理传感器，通过I2C接口通信。内部包含16位ADC，能够将传感器数据数字化为16位输出。此外，还集成了数字运动处理器（DMP）和温度传感器。

**I2C通信**：
MPU6050使用I2C接口与STM32通信，总线时钟频率为400kHz。地址为0x68（AD0引脚接地）或0x69（AD0引脚上拉）。

**数据获取流程**：
```c
void MPU6050_GetData(MPU6050_Data_t *mpu_data)
{
    // 读取加速度计数据
    MPU6050_Read_Accel(&ax, &ay, &az);
    
    // 读取陀螺仪数据
    MPU6050_Read_Gyro(&gx, &gy, &gz);
    
    // 读取温度数据
    MPU6050_Read_Multiple(0x41, buf, 2);
    
    // 转换为物理量
    mpu_data->accel_x = (float)ax / 16384.0f;
    mpu_data->accel_y = (float)ay / 16384.0f;
    mpu_data->accel_z = (float)az / 16384.0f;
    
    mpu_data->gyro_x = (float)gx / 131.0f;
    mpu_data->gyro_y = (float)gy / 131.0f;
    mpu_data->gyro_z = (float)gz / 131.0f;
    
    mpu_data->temp = (float)temp_raw / 340.0f + 36.53f;
}
```

**数据原理与物理量转换**：
1. **加速度计**：
   - 原始值范围：±32768（16位有符号整数）
   - 量程设置：±2g（可配置为±2g、±4g、±8g、±16g）
   - 转换因子：16384 LSB/g（在±2g量程下）
   - 物理意义：静止时，重力加速度在垂直方向上为1g，水平方向为0g

2. **陀螺仪**：
   - 原始值范围：±32768（16位有符号整数）
   - 量程设置：±250°/s（可配置为±250、±500、±1000、±2000°/s）
   - 转换因子：131 LSB/(°/s)（在±250°/s量程下）
   - 物理意义：旋转速率，静止时应接近0

3. **温度传感器**：
   - 转换公式：T(°C) = (TEMP_OUT/340) + 36.53
   - 精度：±1°C
   - 范围：-40~+85°C

**姿态角计算**：
通过加速度计数据计算Roll（翻滚）和Pitch（俯仰）角：
```c
roll = atan2f(accel_y, accel_z) * 57.29578f; // 180/π ≈ 57.29578
pitch = atan2f(-accel_x, sqrt(accel_y*accel_y + accel_z*accel_z)) * 57.29578f;
```
这种计算方法基于静态姿态下，重力加速度在各轴的分量关系，不适用于有明显加速度的动态场景。更准确的姿态估计通常需要结合陀螺仪数据进行互补滤波或卡尔曼滤波。

## 输出模块工作原理

### LED指示系统

**基本结构**：
系统使用4个LED指示不同的报警状态：
- LED0（PF9）：温度报警指示灯，常亮表示温度超过阈值
- LED1（PF10）：湿度报警指示灯，常亮表示湿度超过阈值
- LED2（PE13/TIM1_CH3）：光照报警指示灯，呼吸灯效果表示光照过低
- LED3（PE14/TIM1_CH4）：烟雾报警指示灯，呼吸灯效果表示烟雾过高

**PWM呼吸灯原理**：
呼吸灯效果通过PWM（脉宽调制）技术实现，利用TIM1定时器的通道3和通道4产生可变占空比的PWM信号：

1. **硬件配置**：
   ```c
   // 配置GPIO为复用功能
   GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_TIM1);
   GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_TIM1);
   
   // 配置TIM1
   TIM_TimeBaseStructure.TIM_Period = 1000 - 1;
   TIM_TimeBaseStructure.TIM_Prescaler = 84-1; // 1MHz计数频率
   ```

2. **亮度控制算法**：
   ```c
   // 变亮过程
   breathValue[0] += 5;
   if(breathValue[0] >= PWM_PERIOD) {
       breathValue[0] = PWM_PERIOD;
       breathDir[0] = 0; // 变暗
   }
   
   // 变暗过程
   if(breathValue[0] > 5)
       breathValue[0] -= 5;
   else {
       breathValue[0] = 0;
       breathDir[0] = 1; // 变亮
   }
   
   // 设置PWM占空比
   TIM_SetCompare3(TIM1, breathValue[0]);
   ```

**LED控制函数**：
- `Led_On(LED_Num)`：点亮指定LED（低电平有效）
- `Led_Off(LED_Num)`：关闭指定LED
- `Led_Toggle(LED_Num)`：翻转指定LED状态
- `LED_Breath_Enable(LED_Num)`：使能LED呼吸效果
- `LED_Breath_Disable(LED_Num)`：禁用LED呼吸效果

### 蓝牙通信模块

**硬件基础**：
使用HC-05/HC-06蓝牙模块，通过UART2接口与STM32通信，波特率为9600bps。

**通信原理**：
蓝牙模块作为SPP（Serial Port Profile）设备，与手机等主设备配对后，提供透明的串口数据传输。STM32通过UART接口与蓝牙模块通信，再由蓝牙模块与远端设备无线通信。

**数据接收流程**：
1. 中断接收机制：UART接收到数据时触发中断，将数据存入接收缓冲区
2. 命令解析机制：主循环中定期检查接收缓冲区，解析完整命令
3. 命令格式：两位数字命令 + 空格 + 两位数字参数，如`01 30`

**数据发送机制**：
发送数据使用`Bluetooth_SendString()`函数，内部调用UART发送函数，将字符串通过蓝牙发送到配对设备。

### 蜂鸣器报警模块

**工作原理**：
蜂鸣器采用有源蜂鸣器，直接通过GPIO控制驱动，高电平使能，低电平关闭。

**控制机制**：
```c
// 开启蜂鸣器
void Beep_On(void)
{
    GPIO_SetBits(BEEP_GPIO, BEEP_PIN);
}

// 关闭蜂鸣器
void Beep_Off(void)
{
    GPIO_ResetBits(BEEP_GPIO, BEEP_PIN);
}
```

**报警策略**：
当检测到任何报警条件时，蜂鸣器短促鸣叫一次：
```c
if(alarm_status.any_alarm)
{
    Beep_On();
    Mdelay_Lib(100); // 鸣叫100ms
    Beep_Off();
}
```

## LCD显示系统

### 多页面UI设计

**页面类型**：
系统定义了四种显示页面类型：
```c
typedef enum {
    PAGE_TEMP_HUMID = 0,  // 温湿度页面
    PAGE_LIGHT_SMOKE,     // 光照烟雾页面
    PAGE_ATTITUDE,        // 姿态页面
    PAGE_SYSTEM_INFO      // 系统信息页面
} PageType_t;
```

**页面内容与格式**：

1. **温湿度页面**：
   ```
   === Temp/Humid ===
   T:25C H:60% OK
   ```
   - 第一行：页面标题
   - 第二行：温度值、湿度值、状态（OK或报警类型）

2. **光照烟雾页面**：
   ```
   === Light/Smoke ===
   L:75% MQ2:45ppm
   ```
   - 第一行：页面标题
   - 第二行：光照百分比、MQ2气体传感器ppm值

3. **姿态页面**：
   循环显示三种数据（每2秒切换）：
   ```
   === MPU6050 ===
   A:0.1 -0.2 1.0    // 加速度数据
   ```
   ```
   === MPU6050 ===
   G:0.5 0.3 -0.1    // 陀螺仪数据
   ```
   ```
   === MPU6050 ===
   R:2.5 P:-1.3      // 姿态角数据
   ```

4. **系统信息页面**：
   循环显示四种调试信息（每3秒切换）：
   ```
   === System Info ===
   Time:120s Err:2    // 运行时间和错误计数
   ```
   ```
   === System Info ===
   MQ2:45ppm Ready:1  // MQ2状态
   ```
   ```
   === System Info ===
   Light:75% (Raw:1024) // 光照传感器原始值和百分比
   ```
   ```
   === System Info ===
   DHT:1 L:1 MQ:1     // 传感器状态指示
   ```

**显示更新机制**：
`Display_Update()`函数根据当前选择的页面类型更新LCD显示内容：
```c
void Display_Update(void)
{
    // 只在页面变化时清屏
    if(current_page != previous_page)
    {
        lcd_clear();
        previous_page = current_page;
    }
    
    // 根据当前页面显示内容
    switch(current_page)
    {
        case PAGE_TEMP_HUMID:
            // 显示温湿度页面内容
            break;
        case PAGE_LIGHT_SMOKE:
            // 显示光照烟雾页面内容
            break;
        // ...其他页面
    }
}
```

### 按键切换机制

**硬件基础**：
系统有4个按键（KEY0~KEY3），用于切换不同的显示页面。

**按键检测原理**：
采用软件消抖方式检测按键状态：
```c
uint8_t Key_Debounce(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
    // 检测按键是否按下（低电平有效）
    if(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == 0)
    {
        // 延时消抖
        Mdelay_Lib(10);
        if(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == 0)
        {
            return 1; // 按键确实按下
        }
    }
    return 0; // 按键未按下
}
```

**按键处理流程**：
`Key_Handler()`函数检测四个按键状态，并相应地切换页面：
```c
void Key_Handler(void)
{
    // 按键防抖：200ms内只处理一次按键
    if(system_tick - last_key_time < 200)
        return;
    
    // 检测KEY0 - 温湿度页面
    if(Key_Debounce(KEY0_GPIO, KEY0_PIN))
    {
        if(!key_pressed[0])
        {
            current_page = PAGE_TEMP_HUMID;
            last_key_time = system_tick;
            key_pressed[0] = 1;
        }
    }
    else
    {
        key_pressed[0] = 0;
    }
    
    // 类似处理其他按键...
}
```

**按键映射关系**：
- KEY0：切换到温湿度页面
- KEY1：切换到光照烟雾页面
- KEY2：切换到姿态页面
- KEY3：切换到系统信息页面

## 软件架构设计

### 主循环机制

**系统初始化流程**：
```c
int main(void)
{
    // 系统初始化
    System_Init();
    
    // 传感器初始化
    Sensors_Init();
    
    // 进入主循环
    while(1)
    {
        // 主循环任务
    }
}
```

**主循环任务**：
1. LED运行指示：温度无报警时LED0每秒闪烁一次
2. 呼吸灯处理：定期调用`LED_Breath_Process()`
3. 蓝牙处理：处理接收命令和发送数据
4. 数据采集：定期从传感器读取数据
5. 报警检查：比较传感器数据与阈值，控制LED和蜂鸣器
6. 按键处理：检测按键状态，切换显示页面
7. 显示更新：更新LCD显示内容
8. 延时与计时：10ms延时，更新系统时钟计数器

### 数据采集策略

**采集周期**：
系统每500ms进行一次传感器数据采集，平衡了实时性和系统负载：
```c
// 每500ms读取一次所有传感器
if(system_tick - last_read >= 500)
{
    // 传感器数据读取
}
```

**错误处理机制**：
1. 传感器读取失败时增加错误计数：`sensor_data.error_count++`
2. 对于不稳定的传感器，实现超时机制避免死等
3. 保留上次有效数据，当读取失败时不立即清零

**数据存储结构**：
```c
typedef struct {
    // 温湿度数据 (DHT11)
    uint8_t temperature;
    uint8_t humidity;
    uint8_t dht11_status;
    
    // 光照数据
    uint16_t light_raw_value;
    uint8_t light_percent;
    
    // 烟雾数据 (MQ-2)
    uint16_t smoke_ppm_value;
    float smoke_percent;
    
    // 姿态数据 (MPU6050)
    MPU6050_Data_t mpu_data;
    uint8_t mpu_status;
    
    // 系统状态
    uint32_t error_count;
    uint32_t data_update_count;
} SensorData_t;
```

### 阈值判断与报警

**阈值参数定义**：
```c
// 默认阈值定义
#define DEFAULT_TEMP_HIGH_THRESHOLD  29    // 温度高报警阈值(℃)  
#define DEFAULT_TEMP_LOW_THRESHOLD   20    // 温度低报警阈值(℃)
#define DEFAULT_HUMI_HIGH_THRESHOLD  70    // 湿度高报警阈值(%)
#define DEFAULT_HUMI_LOW_THRESHOLD   40    // 湿度低报警阈值(%)
#define DEFAULT_LIGHT_LOW_THRESHOLD  40    // 光照低报警阈值(0-100)
#define DEFAULT_SMOKE_HIGH_THRESHOLD 120   // 烟雾高报警阈值(ppm)
```

**报警状态结构**：
```c
typedef struct {
    uint8_t temp_high_alarm;
    uint8_t temp_low_alarm; 
    uint8_t humi_high_alarm;
    uint8_t humi_low_alarm;
    uint8_t light_low_alarm;
    uint8_t smoke_high_alarm;
    uint8_t any_alarm;
} AlarmStatus_t;
```

**报警检查逻辑**：
```c
void Alarm_Check(void)
{
    // 温度报警检查
    alarm_status.temp_high_alarm = (sensor_data.temperature > TEMP_HIGH_THRESHOLD);
    alarm_status.temp_low_alarm = (sensor_data.temperature < TEMP_LOW_THRESHOLD);
    
    // 湿度报警检查
    alarm_status.humi_high_alarm = (sensor_data.humidity > HUMI_HIGH_THRESHOLD);
    alarm_status.humi_low_alarm = (sensor_data.humidity < HUMI_LOW_THRESHOLD);
    
    // 光照报警检查
    alarm_status.light_low_alarm = (sensor_data.light_percent < LIGHT_LOW_THRESHOLD);
    
    // 烟雾报警检查
    alarm_status.smoke_high_alarm = (sensor_data.smoke_ppm_value > SMOKE_HIGH_THRESHOLD);
    
    // 综合报警状态
    alarm_status.any_alarm = /* 所有报警条件的或运算 */;
    
    // 控制LED和蜂鸣器
    // ...
}
```

**报警响应方式**：
1. **温度报警**：LED0常亮（PF9）
2. **湿度报警**：LED1常亮（PF10）
3. **光照报警**：LED2呼吸灯效果（PE13/TIM1_CH3）
4. **烟雾报警**：LED3呼吸灯效果（PE14/TIM1_CH4）
5. **任何报警**：蜂鸣器短促鸣叫一次

## 蓝牙命令解析

**命令格式**：
两位数字命令 + 空格 + 两位数字参数，如：`01 30`表示设置温度高阈值为30℃。

**支持的命令列表**：
- `00 XX`：查询系统状态（XX可为任意值）
- `01 XX`：设置温度高阈值为XX℃
- `02 XX`：设置温度低阈值为XX℃
- `03 XX`：设置湿度高阈值为XX%
- `04 XX`：设置湿度低阈值为XX%
- `05 XX`：设置光照低阈值为XX%
- `06 XX`：设置烟雾高阈值为XXppm

**命令解析流程**：
```c
void ProcessReceivedCommand(const char* command)
{
    char cmd[4];
    char value_str[16];
    
    // 解析命令格式：CMD VALUE 或 单独的CMD
    if(sscanf(command, "%2s %s", cmd, value_str) == 2)
    {
        // 有参数的命令
        UserBluetoothCommandHandler(cmd, value_str);
    }
    else if(sscanf(command, "%2s", cmd) == 1)
    {
        // 无参数的命令
        if(strcmp(cmd, BT_CMD_SHOW_STATUS) == 0)
        {
            SendSystemStatus();
        }
        else
        {
            Bluetooth_SendString("ERR: Command needs value\r\n");
        }
    }
}
```

**命令处理示例**：
```c
void UserBluetoothCommandHandler(const char* cmd, const char* value)
{
    uint16_t v = UserBluetoothParseValue(value);
    
    if(strcmp(cmd, BT_CMD_SET_TEMP_HIGH) == 0) {
        if(v <= 60) { 
            TEMP_HIGH_THRESHOLD = v; 
            // 返回确认信息
        }
        else {
            // 返回错误信息
        }
    } 
    // 处理其他命令...
}
```

**系统状态查询**：
`00`命令返回完整的系统状态，包括：
- 所有传感器当前值
- 所有阈值设置
- MPU6050详细数据（加速度、陀螺仪、姿态角、温度）
- 报警状态
- 系统运行时间和错误计数
